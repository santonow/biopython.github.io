---
title: Bayesian phylogenetic inference in BioPython
permalink: wiki/PhyloBayes
layout: wiki
tags:
 - Cookbook
---

Introduction
------------

In this cookbook entry I will briefly explain how bayesian phylogenetic inference works.
Then I will show how one can perform it in BioPython on a simple example: mitochondrial sequences of primates.

Bayesian inference
------------------

All of the bayesian inference is built upon Bayes theorem, which calculates the posterior probability of
the model given the data:

![P(T|X)=\frac{P(X|T)P(T)}{P(X)}](bayes_theorem.png)

In phylogenetic inference, the T could mean a tree topology and its parameters, 
and X the data (for example a multiple sequence alignment).

Because of the enormous amount of possible tree topologies with given number of taxa
(not to mention other parameters such as branch lengths), 
the exact calculation of the posterior probability is impossible.
A common technique that solves this problem is Markov Chain Monte Carlo (MCMC). 
The algorithm works as follows:

1. Start with some tree T<sub>i</sub> (could be a random tree, or a tree generated by some simpler method, e.g. UPGMA).
2. Calculate its likelihood L<sub>i</sub> (probability that the data was generated by this tree).
3. Make a small change to a tree and calculate the likelihood L<sub>j</sub> of the new tree T<sub>j</sub>.
4. Calculate the ratio R = L<sub>j</sub>/L<sub>i</sub>
5. If R > 1, T<sub>j</sub> is accepted as a current tree.
6. If R < 1, T<sub>j</sub> is accepted as a current tree with probability R, otherwise the current stays the same.
7. Repeat steps 3-7 N times, where N is the number of iterations of the method (a hyperparameter).

It can be shown that the algorithm converges to an underlying distribution,
although it is usually difficult to predict when the convergence starts.

Code examples
-------------

The first thing that is needed in bayesian (and ML) phylogenetic inference is the model of evolution.
Currently there are two models of evolution implemented: Felsenstein81 (`Bio.Phylo.EvolutionModel.F81`),
which models only the stationary distribution of nucleotides,
and General Time Reversible model (`Bio.Phylo.EvolutionModel.GTRModel`), which also models the excheangability parameters:
the rates at which specific nucleotides are exchanged.

Generally, the models of evolution compute the probability of changing one symbol to another in given time.
The symbols could be nucleotides, aminoacids, codons, even morphological traits.

Here are some examples:

```python
>>> from Bio.Phylo.EvolutionModel import F81Model, GTRModel
>>> f81model = F81Model() # no parameters - uniform distribution (JC69 model)
>>> f81model.get_probability("A", "C", t=1)
0.18410071547106832
>>> f81model.stat_params = dict(zip("ACGT", [0.2, 0.3, 0.3, 0.2])) # changing the stationary distribution parameters
>>> f81model.get_probability("A", "C", t=1)
0.22233294822941482

>>> from itertools import combinations
>>> gtrmodel = GTRModel() # defaults to an uniform (JC69) model
>>> gtrmodel.get_probability("A", "C", t=1)
0.1841007154710684
>>> gtrmodel.stat_params = dict(zip("ACGT", [0.2, 0.3, 0.3, 0.2])) # changing the stationary distribution
>>> gtrmodel.get_probability("A", "C", t=1)
0.22233294822941482

# but there are also the excheangability parameters
>>> gtrmodel.exch_params = dict(zip(combinations("ACGT", r=2), [1, 2, 3, 4, 5, 6]))
# or, the shorter version
>>> gtrmodel.exch_params = [1, 2, 3, 4, 5, 6]
>>> gtrmodel.get_probability("A", "C", t=1)
0.11773674440501203
```

The second thing is the likelihood computation. This is achieved using a `Bio.Phylo.TreeConstruction.LikelihoodScorer` 
class. To create an instance of this class, you need to pass an `EvolutionModel` instance (currently `F81Model` or `GTRModel`).
Then you call the method `get_score` with tree and MSA as arguments.

```python
>>> from Bio import AlignIO, Phylo
>>> aln = AlignIO.read(open("TreeConstruction/lk_msa.phy"), "phylip") # a sample alignment
>>> print(aln)
SingleLetterAlphabet() alignment with 4 rows and 6 columns
AACACA Alpha
AACGCA Beta
AACGTG Delta
ATTACA Gamma
>>> tree = Phylo.read(open("TreeConstruction/lk.tre"), "newick") # and a sample tree
>>> print(tree)
Tree(rooted=False, weight=1.0)
    Clade(branch_length=0.0)
        Clade(branch_length=3.0)
            Clade(branch_length=1.0, name='Alpha')
            Clade(branch_length=2.5, name='Beta')
        Clade(branch_length=4.5)
            Clade(branch_length=1.0, name='Gamma')
            Clade(branch_length=1.0, name='Delta')
>>> from Bio.Phylo.EvolutionModel import F81Model
>>> evolution_model = F81Model()
>>> from Bio.Phylo.TreeConstruction import LikelihoodScorer
>>> scorer = LikelihoodScorer(evolution_model=evolution_model)
>>> scorer.get_score(tree, aln)
-33.31209847109528
```

The third thing we need is an MCMC algorithm.

TODO: dodać przykłady


Specific example
----------------

As a specific example of bayesian inference we will try to reconstruct the phylogeny of the primates
using mitochondrial sequences. We will compare the result to an existing method - maximum parsimony 
(`Bio.Phylo.TreeConstruction.ParsimonyTreeConstructor`).



    